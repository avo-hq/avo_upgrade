require "fileutils"

# class generated by ChatGPT. Update it as you see fit.
module AvoUpgrade
  class UpgradeTool
    class << self
      def run
        upgrade_tool = new
        puts "DISCLAIMER: Please be aware that this is an automated upgrade and may make unintended changes to your files. We recommend that you carefully review all changes before committing them. While we have taken steps to ensure that the upgrade process is safe and reliable, there is always a possibility of unintended consequences. It is your responsibility to ensure that the modifications made by the upgrade are acceptable for your use case."
        upgrade_tool.enter_to_continue
        print upgrade_tool.summary
        puts "Please make sure you commited all your changes before running this upgrade."
        print "Do you want to run this upgrade? [y/n]: "
        input = gets.chomp
        return unless input == "y" || input == "Y"
        upgrade_tool.run
      end
    end

    def avo_global_files
      Dir.glob(File.join(Rails.root.join("app", "avo"), '**/*')).select { |f| File.file?(f) } +
      Dir.glob(File.join(Rails.root.join("app", "controllers", "avo"), '**/*')).select { |f| File.file?(f) } +
      Dir.glob(File.join(Rails.root.join("app", "views", "avo"), '**/*')).select { |f| File.file?(f) }
    end

    def class_names_for(component)
      names = []

      Dir.glob(File.join(send("#{component}_path"), '**/*.rb')).each do |file|
        # Match class definitions in the file
        File.read(file).scan(/class\s+(\w+)/).each do |match|
          # Add the matched class names to the list
          names << match.first
        end
      end

      names
    end

    # Dynamicly create path method for each component
    # def resources_path, def actions_path, def filters_path, def resource_tools_path def dashboards_path, def cards_path
    [:resources, :actions, :filters, :resource_tools, :dashboards, :cards].each do |component|
      define_method "#{component}_path" do
        Rails.root.join("app", "avo", component.to_s)
      end
    end

    def files_from(path)
      Dir.glob("#{path}/*.rb").select { |file| File.file?(file) }
    end

    def replace_text_on(files, hash, exact_match: true)
      files.each do |file|
        text = File.read(file)

        hash.each do |old_text, new_text|
          old_text = /\b#{Regexp.escape(old_text)}\b/ if exact_match
          text.gsub!(old_text, new_text)
        end

        File.open(file, 'w') { |f| f.write(text) }
      end
    end

    def remove_text_on(files, text_array)
      replace_text_on(files, text_array.map { |text| [text, ""] }.to_h, exact_match: false)
    end

    def remove_block_arg_on(files, text_array)
      match_array = text_array.map do |text|
        if proc_arg?(text)
          proc_arg_match_params(text)
        else
          lambda_arg_match_params(text)
        end
      end
      replace_text_on(files, match_array.to_h, exact_match: false)
    end

    def replace_in_filename(old_text, new_text, path:)
      Dir.glob("#{path}/*.rb").each do |file_path|
        `#{@mv_cmd == "1" ? "git mv" : "mv"} #{file_path} #{file_path.gsub(/#{old_text}/, new_text)}`
      end
    end

    def enter_to_continue
      print "\nPress ENTER to continue."
      gets.chomp
    end

    # Receives the code at the beginning of a line and deletes the line.
    def remove_config(config)
      avo_config_path = File.join Rails.root.join("config", "initializers", "avo.rb")

      # Read the content of the file into an array of lines
      lines = File.readlines(avo_config_path)

      # Open the file for writing
      File.open(avo_config_path, "w") do |file|
        lines.each do |line|
          # Check if the line starts with the given config code
          if line.strip.start_with?(config)
            # Do nothing, skip the line
          else
            # Write the line to the file
            file.puts(line)
          end
        end
      end
    end

    private

    def proc_arg?(text)
      /\|/.match?(text)
    end

    def lambda_arg_match_params(proc_arg_text)
      [
        /->\s*#{Regexp.escape(proc_arg_text)}/,
        '->'
      ]
    end

    def proc_arg_match_params(lambda_arg_text)
      [
        /\b#{Regexp.escape(lambda_arg_text)}\b/,
        ''
      ]
    end
  end
end
